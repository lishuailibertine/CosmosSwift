// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: terra/oracle/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryExchangeRateRequest is the request type for the Query/ExchangeRate RPC method.
public struct Terra_Oracle_V1beta1_QueryExchangeRateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom defines the denomination to query for.
  public var denom: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryExchangeRateResponse is response type for the
/// Query/ExchangeRate RPC method.
public struct Terra_Oracle_V1beta1_QueryExchangeRateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exchange_rate defines the exchange rate of Luna denominated in various Terra
  public var exchangeRate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryExchangeRatesRequest is the request type for the Query/ExchangeRates RPC method.
public struct Terra_Oracle_V1beta1_QueryExchangeRatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryExchangeRatesResponse is response type for the
/// Query/ExchangeRates RPC method.
public struct Terra_Oracle_V1beta1_QueryExchangeRatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exchange_rates defines a list of the exchange rate for all whitelisted denoms.
  public var exchangeRates: [Cosmos_Base_V1beta1_DecCoin] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryTobinTaxRequest is the request type for the Query/TobinTax RPC method.
public struct Terra_Oracle_V1beta1_QueryTobinTaxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom defines the denomination to query for.
  public var denom: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryTobinTaxResponse is response type for the
/// Query/TobinTax RPC method.
public struct Terra_Oracle_V1beta1_QueryTobinTaxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tobin_taxe defines the tobin tax of a denom
  public var tobinTax: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryTobinTaxesRequest is the request type for the Query/TobinTaxes RPC method.
public struct Terra_Oracle_V1beta1_QueryTobinTaxesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryTobinTaxesResponse is response type for the
/// Query/TobinTaxes RPC method.
public struct Terra_Oracle_V1beta1_QueryTobinTaxesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tobin_taxes defines a list of the tobin tax of all whitelisted denoms
  public var tobinTaxes: [Terra_Oracle_V1beta1_Denom] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryActivesRequest is the request type for the Query/Actives RPC method.
public struct Terra_Oracle_V1beta1_QueryActivesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryActivesResponse is response type for the
/// Query/Actives RPC method.
public struct Terra_Oracle_V1beta1_QueryActivesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// actives defines a list of the denomination which oracle prices aggreed upon.
  public var actives: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryVoteTargetsRequest is the request type for the Query/VoteTargets RPC method.
public struct Terra_Oracle_V1beta1_QueryVoteTargetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryVoteTargetsResponse is response type for the
/// Query/VoteTargets RPC method.
public struct Terra_Oracle_V1beta1_QueryVoteTargetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// vote_targets defines a list of the denomination in which everyone
  /// should vote in the current vote period.
  public var voteTargets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryFeederDelegationRequest is the request type for the Query/FeederDelegation RPC method.
public struct Terra_Oracle_V1beta1_QueryFeederDelegationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// validator defines the validator address to query for.
  public var validatorAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryFeederDelegationResponse is response type for the
/// Query/FeederDelegation RPC method.
public struct Terra_Oracle_V1beta1_QueryFeederDelegationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// feeder_addr defines the feeder delegation of a validator
  public var feederAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryMissCounterRequest is the request type for the Query/MissCounter RPC method.
public struct Terra_Oracle_V1beta1_QueryMissCounterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// validator defines the validator address to query for.
  public var validatorAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryMissCounterResponse is response type for the
/// Query/MissCounter RPC method.
public struct Terra_Oracle_V1beta1_QueryMissCounterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// miss_counter defines the oracle miss counter of a validator
  public var missCounter: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregatePrevoteRequest is the request type for the Query/AggregatePrevote RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregatePrevoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// validator defines the validator address to query for.
  public var validatorAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregatePrevoteResponse is response type for the
/// Query/AggregatePrevote RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregatePrevoteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// aggregate_prevote defines oracle aggregate prevote submitted by a validator in the current vote period
  public var aggregatePrevote: Terra_Oracle_V1beta1_AggregateExchangeRatePrevote {
    get {return _aggregatePrevote ?? Terra_Oracle_V1beta1_AggregateExchangeRatePrevote()}
    set {_aggregatePrevote = newValue}
  }
  /// Returns true if `aggregatePrevote` has been explicitly set.
  public var hasAggregatePrevote: Bool {return self._aggregatePrevote != nil}
  /// Clears the value of `aggregatePrevote`. Subsequent reads from it will return its default value.
  public mutating func clearAggregatePrevote() {self._aggregatePrevote = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _aggregatePrevote: Terra_Oracle_V1beta1_AggregateExchangeRatePrevote? = nil
}

/// QueryAggregatePrevotesRequest is the request type for the Query/AggregatePrevotes RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregatePrevotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregatePrevotesResponse is response type for the
/// Query/AggregatePrevotes RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregatePrevotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// aggregate_prevotes defines all oracle aggregate prevotes submitted in the current vote period
  public var aggregatePrevotes: [Terra_Oracle_V1beta1_AggregateExchangeRatePrevote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregateVoteRequest is the request type for the Query/AggregateVote RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregateVoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// validator defines the validator address to query for.
  public var validatorAddr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregateVoteResponse is response type for the
/// Query/AggregateVote RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregateVoteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// aggregate_vote defines oracle aggregate vote submitted by a validator in the current vote period
  public var aggregateVote: Terra_Oracle_V1beta1_AggregateExchangeRateVote {
    get {return _aggregateVote ?? Terra_Oracle_V1beta1_AggregateExchangeRateVote()}
    set {_aggregateVote = newValue}
  }
  /// Returns true if `aggregateVote` has been explicitly set.
  public var hasAggregateVote: Bool {return self._aggregateVote != nil}
  /// Clears the value of `aggregateVote`. Subsequent reads from it will return its default value.
  public mutating func clearAggregateVote() {self._aggregateVote = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _aggregateVote: Terra_Oracle_V1beta1_AggregateExchangeRateVote? = nil
}

/// QueryAggregateVotesRequest is the request type for the Query/AggregateVotes RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregateVotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryAggregateVotesResponse is response type for the
/// Query/AggregateVotes RPC method.
public struct Terra_Oracle_V1beta1_QueryAggregateVotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// aggregate_votes defines all oracle aggregate votes submitted in the current vote period
  public var aggregateVotes: [Terra_Oracle_V1beta1_AggregateExchangeRateVote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryParamsRequest is the request type for the Query/Params RPC method.
public struct Terra_Oracle_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryParamsResponse is the response type for the Query/Params RPC method.
public struct Terra_Oracle_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines the parameters of the module.
  public var params: Terra_Oracle_V1beta1_Params {
    get {return _params ?? Terra_Oracle_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Terra_Oracle_V1beta1_Params? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Terra_Oracle_V1beta1_QueryExchangeRateRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryExchangeRateResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryExchangeRatesRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryExchangeRatesResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryTobinTaxRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryTobinTaxResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryTobinTaxesRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryTobinTaxesResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryActivesRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryActivesResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryVoteTargetsRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryVoteTargetsResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryFeederDelegationRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryFeederDelegationResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryMissCounterRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryMissCounterResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregatePrevoteRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregatePrevoteResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregatePrevotesRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregatePrevotesResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregateVoteRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregateVoteResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregateVotesRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryAggregateVotesResponse: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryParamsRequest: @unchecked Sendable {}
extension Terra_Oracle_V1beta1_QueryParamsResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "terra.oracle.v1beta1"

extension Terra_Oracle_V1beta1_QueryExchangeRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryExchangeRateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryExchangeRateRequest, rhs: Terra_Oracle_V1beta1_QueryExchangeRateRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryExchangeRateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryExchangeRateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.exchangeRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.exchangeRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryExchangeRateResponse, rhs: Terra_Oracle_V1beta1_QueryExchangeRateResponse) -> Bool {
    if lhs.exchangeRate != rhs.exchangeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryExchangeRatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryExchangeRatesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryExchangeRatesRequest, rhs: Terra_Oracle_V1beta1_QueryExchangeRatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryExchangeRatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryExchangeRatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_rates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exchangeRates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchangeRates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exchangeRates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryExchangeRatesResponse, rhs: Terra_Oracle_V1beta1_QueryExchangeRatesResponse) -> Bool {
    if lhs.exchangeRates != rhs.exchangeRates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryTobinTaxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTobinTaxRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryTobinTaxRequest, rhs: Terra_Oracle_V1beta1_QueryTobinTaxRequest) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryTobinTaxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTobinTaxResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tobin_tax"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tobinTax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tobinTax.isEmpty {
      try visitor.visitSingularStringField(value: self.tobinTax, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryTobinTaxResponse, rhs: Terra_Oracle_V1beta1_QueryTobinTaxResponse) -> Bool {
    if lhs.tobinTax != rhs.tobinTax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryTobinTaxesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTobinTaxesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryTobinTaxesRequest, rhs: Terra_Oracle_V1beta1_QueryTobinTaxesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryTobinTaxesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTobinTaxesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tobin_taxes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tobinTaxes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tobinTaxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tobinTaxes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryTobinTaxesResponse, rhs: Terra_Oracle_V1beta1_QueryTobinTaxesResponse) -> Bool {
    if lhs.tobinTaxes != rhs.tobinTaxes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryActivesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryActivesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryActivesRequest, rhs: Terra_Oracle_V1beta1_QueryActivesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryActivesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryActivesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actives"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.actives) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actives.isEmpty {
      try visitor.visitRepeatedStringField(value: self.actives, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryActivesResponse, rhs: Terra_Oracle_V1beta1_QueryActivesResponse) -> Bool {
    if lhs.actives != rhs.actives {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryVoteTargetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryVoteTargetsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryVoteTargetsRequest, rhs: Terra_Oracle_V1beta1_QueryVoteTargetsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryVoteTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryVoteTargetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_targets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.voteTargets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteTargets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.voteTargets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryVoteTargetsResponse, rhs: Terra_Oracle_V1beta1_QueryVoteTargetsResponse) -> Bool {
    if lhs.voteTargets != rhs.voteTargets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryFeederDelegationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryFeederDelegationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryFeederDelegationRequest, rhs: Terra_Oracle_V1beta1_QueryFeederDelegationRequest) -> Bool {
    if lhs.validatorAddr != rhs.validatorAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryFeederDelegationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryFeederDelegationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feeder_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feederAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feederAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.feederAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryFeederDelegationResponse, rhs: Terra_Oracle_V1beta1_QueryFeederDelegationResponse) -> Bool {
    if lhs.feederAddr != rhs.feederAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryMissCounterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryMissCounterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryMissCounterRequest, rhs: Terra_Oracle_V1beta1_QueryMissCounterRequest) -> Bool {
    if lhs.validatorAddr != rhs.validatorAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryMissCounterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryMissCounterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "miss_counter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.missCounter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.missCounter != 0 {
      try visitor.visitSingularUInt64Field(value: self.missCounter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryMissCounterResponse, rhs: Terra_Oracle_V1beta1_QueryMissCounterResponse) -> Bool {
    if lhs.missCounter != rhs.missCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregatePrevoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregatePrevoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregatePrevoteRequest, rhs: Terra_Oracle_V1beta1_QueryAggregatePrevoteRequest) -> Bool {
    if lhs.validatorAddr != rhs.validatorAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregatePrevoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregatePrevoteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_prevote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aggregatePrevote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aggregatePrevote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregatePrevoteResponse, rhs: Terra_Oracle_V1beta1_QueryAggregatePrevoteResponse) -> Bool {
    if lhs._aggregatePrevote != rhs._aggregatePrevote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregatePrevotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregatePrevotesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregatePrevotesRequest, rhs: Terra_Oracle_V1beta1_QueryAggregatePrevotesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregatePrevotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregatePrevotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_prevotes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aggregatePrevotes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregatePrevotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregatePrevotes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregatePrevotesResponse, rhs: Terra_Oracle_V1beta1_QueryAggregatePrevotesResponse) -> Bool {
    if lhs.aggregatePrevotes != rhs.aggregatePrevotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregateVoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregateVoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregateVoteRequest, rhs: Terra_Oracle_V1beta1_QueryAggregateVoteRequest) -> Bool {
    if lhs.validatorAddr != rhs.validatorAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregateVoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregateVoteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_vote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aggregateVote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aggregateVote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregateVoteResponse, rhs: Terra_Oracle_V1beta1_QueryAggregateVoteResponse) -> Bool {
    if lhs._aggregateVote != rhs._aggregateVote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregateVotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregateVotesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregateVotesRequest, rhs: Terra_Oracle_V1beta1_QueryAggregateVotesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryAggregateVotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryAggregateVotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregate_votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateVotes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregateVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateVotes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryAggregateVotesResponse, rhs: Terra_Oracle_V1beta1_QueryAggregateVotesResponse) -> Bool {
    if lhs.aggregateVotes != rhs.aggregateVotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryParamsRequest, rhs: Terra_Oracle_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Terra_Oracle_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Terra_Oracle_V1beta1_QueryParamsResponse, rhs: Terra_Oracle_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
